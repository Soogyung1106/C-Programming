#include <stdio.h>

//32비트(x86), 64비트(x64) -> 운영체재가 달라짐. 메모리 체계 다름
//-> 32비트로(x86)으로 설정하고 프로그래밍해야!! 그래야 64비트 컴터에서도 코딩이 호환됨! long 4바이트 ->8바이트 (운영체제 64비트로 바뀌면)

void main(void) {

	//대표적으로 많이 쓰는 자료형
	//int a; //정수형 4바이트 a = 10인 경우 칸에 이진수로 변환되서 들어감. 컴터는 이진수밖에 모르기 때문에
	//double b; //실수형 8바이트
	//char c; //문자형 1바이트

	////예약어 : 프로그램에 이미 내장된 이름 -> 변수 이름 지을 때 예약어랑 겹치지 않도록 조심!
	//a = 10; //대입 연산자
	//printf("%d\n", a); // 변수 <-> 상수 : 완전 반대 개념 

	//a = 20; //변수 초기화 (-> 그릇이 만들어지면 그 곳에는 빈 공간이 아니라 쓰레기값으로 차있다.)
	//printf("%d\n", a); //'변수 호출' 용어!

	/*float w = 99.9;
	double h = 193.4;

	printf("몸무게 : %f\n", w);
	printf("키 : %f\n", h);*/

	// 더블이거나 플롯이나 출력할 때는 둘다 %f 그릇에 담음
	// <주의>
	// double 입력할 때는 %lf(long float) 그릇에 담아야함!   

	//char ch = 'A';
	//printf("%c\n", ch);


	//char str[10]="Hello"; //1바이트짜리가 10칸 만들어진다.
	//char str[5] = "Hello"; 
	//<?> 에러
	//\0 (널문자) 쓰레기값을 읽지 않고 break를 걸어주는 기능일 널문자 1개가 들어갈 공간을 안 주었기 때문에, 
	//최소 (들어갈 문자 + 1)칸으로 배열을 생성해주던가 넉넉히 잡아줘야 함!
	//(ex) char str[6] = "Hello"; char str[100] = "Hello";
	//char str[6] = "Hello";
	//printf("%s\n", str);

	//<문제>
	//double a = 8.888;
	//printf("%f\n", a);

	//char b = 'd';
	//printf("%c\n", b);

	//char str[10] = "이순신";
	//printf("%s\n", str);

	//double c = 3.24 + 5.34;
	//printf("%f\n", c);

	//int d = 10+20;
	//printf("%d\n", d);

	//double e = 3.333;
	//printf("%f\n", e);
	//
	//char str1[5] = "po";
	//printf("%s\n", str1);
	//
	////char f = 'ㄱ';  //<?> 오류 : 어떤 한글을 저장하더라도 출력하면 ?이 저장되었다고 나옴
	////printf("%c\n", f);
	////알파벳 a와 달리 한글은 2바이트짜리이기 때문에 1바이트 메모리 공간에 저장하지 않고 한 글자더도 문자열로서 저장해야!
	//char str0[3] = "ㄱ";
	//printf("%s\n", str0);
	//
	//char str2[20] = "가나다라abcde";
	//printf("%s\n", str2);
	//
	//char str3[20] = "abcd12345";
	//printf("%s\n", str3);
	//
	//char str4[20] = "010-2314-4212";
	//printf("%s\n", str4);

	//(8진수 실습)
	//int m = 0100; //8진수식 표기
	//printf("%d\n", m); //8진수를 10진수 그릇에 담아 표현해라!
	//printf("%o\n", m);//8진수를 9진수 그릇에 담아 표현해라!

	//(대입형변환) : 대입하면서 알아서 형변환 되는 경우(큰 자료형에서 작은 자료형으로 데이터를 담을 경우 : 데이터 손실 발생)
	//int a; //4바이트 
	//double b; //8바이트

	//a = 10;
	//b = a; // 실수형으로 바뀌어서 출력됨

	//printf("%d, %f\n",a,b);


	//(방법1)
	//int a;
	//double b;

	//b = 10.123;
	//a = b;

	//printf("%d, %f\n", a, b); //데이터 손실 발생

	//int a = 5;
	//int b = 2;
	//double res;

	//res = (double)a / b; // <?> 2.5가 아니라 2.0인 이유 : 정수 나누기 정수 해서
	////2.5를 나오게 하고 싶은 경우 -> (sol)둘중 하나가 적어도 실수여야 혹은 강제형변환!
	//printf("%f\n", res);

	//(방법2)
	/*
	int a = 5;
	double b = 2.0;
	double res;

	res = a / b; // <?> 2.5가 아니라 2.0인 이유 : 정수 나누기 정수 해서
					 //2.5를 나오게 하고 싶은 경우 -> (sol)둘중 하나가 적어도 실수여야 혹은 강제형변환!
	printf("%f\n", res);
	*/
	
	/*
	문자형 char은 최대 127까지만 저장이 가능하다고 한다.
	char -> 차지하는 메모리 크기 : 1바이트 -> 저장 가능한 수 : -128 ~ 127(2의 7제곱-1)
	*/

	//<?> char형은 문자형인데 어떻게 수가 저장이 가능함? 문자형 저장이 아니라?	
	// char형도 크게 자료형을 2가지로 나누었을 때 정수형에 들어가서 그런것인가?

	//char a[3] = "가";
	
	char a = 127;
	printf("%d\n", a); // 127출력됨
	
	char b = 128;
	printf("%d\n", b); //<오류> -128출력됨 <- 그 이유 : 오버플로우 발생(저장 가능한 수는 127까지만!)
}